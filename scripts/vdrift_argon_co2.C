///////////////////////////////////////////////////////////////////////////////
// example: time_to_distance(1400.) // HV in volts
//-----------------------------------------------------------------------------
// drif velocity as a function of drift radius
// V in volts, R in cm
//-----------------------------------------------------------------------------
#include "TGraph.h"
#include "TH1.h"
#include "TH2.h"
#include "TCanvas.h"
#include "TRandom3.h"

double vdrift_argon_co2(double R, float HV) {
  // Ar:Co2 80:20 from NIMA 340 (1994) 485-490 ; 80:20 - last column
  float data[] {
    0.070, 0.52, 0.45, 0.42, 0.37, 0.34, 0.30, 0.29, 0.27, 0.26, 0.26, 0.25, 0.22, 0.21,
    0.140, 1.15, 1.04, 0.91, 0.83, 0.74, 0.69, 0.65, 0.60, 0.57, 0.54, 0.52, 0.48, 0.46,
    0.210, 1.89, 1.71, 1.48, 1.36, 1.20, 1.10, 1.02, 0.96, 0.90, 0.85, 0.80, 0.74, 0.71,
    0.280, 2.77, 2.48, 2.13, 1.93, 1.70, 1.56, 1.45, 1.34, 1.25, 1.17, 1.10, 1.02, 0.97,
    0.350, 3.56, 3.23, 2.84, 2.59, 2.28, 2.10, 1.94, 1.78, 1.65, 1.53, 1.43, 1.32, 1.26,
    0.420, 4.18, 3.91, 3.51, 3.24, 2.89, 2.65, 2.44, 2.23, 2.08, 1.92, 1.78, 1.65, 1.57,
    0.490, 4.57, 4.41, 4.11, 3.85, 3.49, 3.24, 2.99, 2.74, 2.55, 2.35, 2.17, 2.00, 1.90,
    0.559, 4.78, 4.73, 4.56, 4.35, 4.02, 3.77, 3.52, 3.23, 3.03, 2.80, 2.59, 2.39, 2.26,
    0.629, 4.82, 4.90, 4.85, 4.74, 4.48, 4.27, 4.04, 3.75, 3.52, 3.28, 3.03, 2.80, 2.65,
    0.699, 4.79, 4.96, 5.00, 4.95, 4.82, 4.66, 4.49, 4.19, 3.99, 3.73, 3.46, 3.23, 3.05,
    0.769, 4.71, 4.91, 5.06, 5.08, 5.04, 5.00, 4.81, 4.60, 4.40, 4.18, 3.90, 3.65, 3.47,
    0.839, 4.62, 4.86, 5.05, 5.15, 5.18, 5.18, 5.10, 4.89, 4.73, 4.55, 4.29, 4.06, 3.84,
    0.909, 4.53, 4.78, 5.01, 5.14, 5.24, 5.30, 5.27, 5.14, 5.05, 4.90, 4.68, 4.44, 4.25,
    0.979, 4.43, 4.70, 4.95, 5.11, 5.23, 5.37, 5.38, 5.29, 5.22, 5.15, 4.96, 4.77, 4.58,
    1.049, 4.35, 4.63, 4.90, 5.07, 5.21, 5.39, 5.47, 5.42, 5.40, 5.38, 5.21, 5.08, 4.91,
    1.119, 4.30, 4.57, 4.82, 5.01, 5.18, 5.38, 5.48, 5.47, 5.47, 5.49, 5.41, 5.31, 5.15,
    1.189, 4.26, 4.51, 4.76, 4.97, 5.14, 5.35, 5.46, 5.53, 5.56, 5.60, 5.56, 5.47, 5.36,
    1.259, 4.23, 4.47, 4.72, 4.92, 5.10, 5.31, 5.45, 5.55, 5.61, 5.66, 5.67, 5.63, 5.56,
    1.329, 4.20, 4.44, 4.69, 4.87, 5.07, 5.28, 5.40, 5.55, 5.63, 5.70, 5.74, 5.73, 5.68,
    1.399, 4.20, 4.43, 4.65, 4.84, 5.03, 5.24, 5.39, 5.52, 5.61, 5.72, 5.80, 5.81, 5.77,
    1.573, 4.20, 4.40, 4.63, 4.80, 4.97, 5.19, 5.33, 5.48, 5.58, 5.70, 5.84, 5.90, 5.92,
    1.748, 4.24, 4.43, 4.63, 4.81, 4.95, 5.14, 5.30, 5.44, 5.54, 5.67, 5.82, 5.91, 5.98,
    1.923, 4.29, 4.48, 4.68, 4.80, 4.97, 5.12, 5.31, 5.44, 5.53, 5.66, 5.80, 5.93, 6.02,
    2.098, 4.36, 4.56, 4.73, 4.88, 5.01, 5.15, 5.31, 5.45, 5.54, 5.68, 5.82, 5.94, 6.02,
    2.448, 4.49, 4.68, 4.85, 4.99, 5.13, 5.26, 5.41, 5.50, 5.62, 5.74, 5.85, 6.01, 6.09,
    2.797, 4.57, 4.77, 4.96, 5.11, 5.24, 5.37, 5.52, 5.63, 5.76, 5.87, 5.95, 6.08, 6.19,
    3.147, 4.59, 4.85, 5.05, 5.19, 5.39, 5.49, 5.63, 5.78, 5.88, 5.99, 6.05, 6.20, 6.35,
    3.497, 4.58, 4.85, 5.07, 5.27, 5.44, 5.55, 5.76, 5.85, 5.99, 6.08, 6.21, 6.33, 6.48,
    3.846, 4.56, 4.82, 5.07, 5.26, 5.47, 5.61, 5.79, 5.94, 6.10, 6.18, 6.32, 6.45, 6.64,
    4.196, 4.50, 4.79, 5.05, 5.25, 5.49, 5.66, 5.83, 5.98, 6.14, 6.26, 6.41, 6.56, 6.72,
    4.545, 4.47, 4.77, 5.00, 5.23, 5.50, 5.67, 5.82, 6.02, 6.18, 6.32, 6.46, 6.60, 6.83,
    4.895, 4.44, 4.72, 4.98, 5.17, 5.45, 5.65, 5.79, 6.04, 6.23, 6.34, 6.51, 6.64, 6.87,
    5.245, 4.40, 4.69, 4.94, 5.14, 5.39, 5.58, 5.77, 6.03, 6.18, 6.32, 6.56, 6.71, 6.89,
    5.735, 4.40, 4.65, 4.92, 5.12, 5.35, 5.55, 5.74, 5.97, 6.15, 6.33, 6.51, 6.70, 6.85,
    -1.
  };

  int npt(0);
 
  double e[100], v[100];

  for (int i=0; data[14*i]>0; ++i) {
    int loc = 14*i;
    e[npt] = data[loc];
    v[npt] = data[loc+13];
    npt++;
  }

  TGraph* gr = new TGraph(npt,e,v);
  gr->SetTitle("drift velocity in Ar:CO2 (80%:20%)");
  gr->SetMarkerStyle(20);
  gr->SetMarkerSize (1);
  gr->Draw("ALP");

  double c = HV/log(200.);

  double e_field = c/R/1.e3;            // convert to kV/cm, R in cm
                                        // determine V(drift) as a function of E
  int loc = npt;
  for (int i=0; i<npt; i++) {
    if (e_field < e[i]) {
      loc = i-1;
      break;
    }
  }
                                        // electric field in between e[loc] and e[loc+1], interpolate
  double vdr(-1.);

  if (loc == -1) {
                                        // low field , scale down to zero linearly
    vdr = v[0]*(e_field/e[0]);
  }
  else if (loc < npt-1) {
    vdr = v[loc] + (e_field-e[loc])*(v[loc+1]-v[loc])/(e[loc+1]-e[loc]);
  }
  else {
    vdr = v[npt-1];
  }
  //  printf("R:%10.4f E:%10.4f loc:%2i vdr:%10.4f\n",R,e_field,loc,vdr);
  return vdr*10; // in um/ns
}


//-----------------------------------------------------------------------------
// HV in volts
//-----------------------------------------------------------------------------
int time_vs_distance(double HV) {

  double dist(0), time(0);
  double step(25.e-4) ; // 25 microns;
  for (int i=0; i<100; i++) {
    dist += step;
    double vdr = vdrift_argon_co2(dist, HV);
    double dt = step*1e4/vdr; // in ns
    time += dt;
    printf("-- dist:%12.4f time:%12.4f\n",dist,time);
  }
  return 0;
}

//-----------------------------------------------------------------------------
// returns drift time in ns
//-----------------------------------------------------------------------------
double drift_time(double R, double HV) {

  double dist(0), time(0);
  double step = R/100;

  for (int i=0; i<100; i++) {
    dist += step;
    double vdr = vdrift_argon_co2(dist, HV);
    double dt  = step*1e4/vdr; // in ns
    time      += dt;
  }
  return time;
}


//-----------------------------------------------------------------------------
// preferred solution: R = 61.3*(T+1.6)
//------------------------------------------------------------------------------
int test_resolution(int NEvents, double VDrift=60.3, double MinR=0, double MaxR=2500, double HV=1400) {

  TRandom3 rn3;

  TCanvas* c = new TCanvas("c","c",1200,800);
  c->Divide(2,1);
  
  c->cd(1);
  TH1F* h  = new TH1F("h","h",1000,-5,5);
  c->cd(2);
  TH2F* h2 = new TH2F("h2","h2",250,0,2500,500,-2.5,2.5);
  
  for (int i=0; i<NEvents; i++) {
    double dist = MinR+rn3.Rndm()*(MaxR-MinR);   // in um
    double t1   = dist/VDrift-1.6;
    double t2   = drift_time(dist*1.e-4,HV);
    h->Fill(t1-t2);
    h2->Fill(dist,t1-t2);
  }

  c->cd(1);
  h->Draw();
  
  c->cd(2);
  h2->Draw();
  
  return 0;
}


//-----------------------------------------------------------------------------
int plot_v_vs_r(double HV=1400) {

  int const npt(100);
  double r[npt], v[npt];
  for (int i=0; i<100; i++) {
    r[i] = 0.0025*i;
    v[i] = vdrift_argon_co2(r[i], HV);
  }

  TGraph* gr = new TGraph(npt,r,v);
  gr->SetTitle("Vdrift vs R(mm)");
  gr->Draw("ALP");
  return 0;
}
